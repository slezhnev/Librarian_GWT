package ru.lsv.gwtlib.downloader;

import java.awt.BorderLayout;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.lang.reflect.InvocationTargetException;
import java.net.URI;
import java.net.URLDecoder;
import java.nio.charset.Charset;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.TreeSet;

import javax.swing.ImageIcon;
import javax.swing.JButton;
import javax.swing.JFileChooser;
import javax.swing.JFrame;
import javax.swing.JOptionPane;
import javax.swing.JProgressBar;
import javax.swing.JTree;
import javax.swing.SwingUtilities;
import javax.swing.UIManager;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeModel;

import org.apache.http.Header;
import org.apache.http.HttpEntity;
import org.apache.http.HttpResponse;
import org.apache.http.client.CookieStore;
import org.apache.http.client.methods.HttpGet;
import org.apache.http.client.protocol.ClientContext;
import org.apache.http.entity.ContentType;
import org.apache.http.impl.client.BasicCookieStore;
import org.apache.http.impl.client.DefaultHttpClient;
import org.apache.http.protocol.BasicHttpContext;
import org.apache.http.protocol.HttpContext;

import ru.lsv.gwtlib.server.data.Utils;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.JsonArray;
import com.google.gson.JsonParser;
import com.jgoodies.looks.LookUtils;
import com.jgoodies.looks.Options;

public class Downloader {

	private JFrame frame;
	private JTree booksTree;
	private DefaultHttpClient httpclient;
	private HttpContext httpContext;
	private ConnectToLibrary connectDialog;
	private JProgressBar progressBar;
	private JButton downloadBtn;
	/**
	 * Список книг к скачиванию
	 */
	private List<DownloaderBook> books = null;

	/**
	 * Launch the application.
	 */
	public static void main(String[] args) {
		configureUI();
		EventQueue.invokeLater(new Runnable() {
			public void run() {
				try {
					Downloader window = new Downloader();
					window.frame.setVisible(true);
				} catch (Exception e) {
					e.printStackTrace();
				}
			}
		});
	}

	/**
	 * Конфигурирование UI
	 */
	private static void configureUI() {
		UIManager.put(Options.USE_SYSTEM_FONTS_APP_KEY, Boolean.TRUE);
		Options.setDefaultIconSize(new Dimension(18, 18));

		String lafName = LookUtils.IS_OS_WINDOWS_XP ? Options
				.getCrossPlatformLookAndFeelClassName() : Options
				.getSystemLookAndFeelClassName();

		try {
			UIManager.setLookAndFeel(lafName);
		} catch (Exception e) {
			System.err.println("Can't set look & feel:" + e);
		}
	}

	/**
	 * Create the application.
	 */
	public Downloader() {
		initialize();
	}

	/**
	 * Initialize the contents of the frame.
	 */
	private void initialize() {
		frame = new JFrame();
		frame.setTitle("Librarian downloader");
		frame.setBounds(100, 100, 747, 684);
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
		frame.getContentPane().setLayout(new BorderLayout(0, 0));

		booksTree = new JTree();
		booksTree.setRootVisible(false);
		frame.getContentPane().add(booksTree);

		downloadBtn = new JButton(
				"\u0417\u0430\u0433\u0440\u0443\u0437\u0438\u0442\u044C \u043A\u043D\u0438\u0433\u0438");
		downloadBtn.addActionListener(new ActionListener() {
			public void actionPerformed(ActionEvent arg0) {
				doDownload();
			}
		});
		downloadBtn
				.setIcon(new ImageIcon(
						Downloader.class
								.getResource("/ru/lsv/gwtlib/downloader/resources/save_as_16_h.png")));
		frame.getContentPane().add(downloadBtn, BorderLayout.SOUTH);
		frame.setLocationRelativeTo(null);

		DefaultMutableTreeNode root = new DefaultMutableTreeNode("root");
		DefaultMutableTreeNode loading = new DefaultMutableTreeNode(
				"Идет загрузка...");
		root.add(loading);
		((DefaultTreeModel) booksTree.getModel()).setRoot(root);
		((DefaultTreeModel) booksTree.getModel()).reload();
		booksTree.setSelectionPaths(null);

		progressBar = new JProgressBar();
		frame.getContentPane().add(progressBar, BorderLayout.NORTH);

		//
		httpclient = new DefaultHttpClient();
		// Инициализируем cookie store
		CookieStore cookieStore = new BasicCookieStore();
		httpContext = new BasicHttpContext();
		httpContext.setAttribute(ClientContext.COOKIE_STORE, cookieStore);
		//
		connectDialog = new ConnectToLibrary(frame, httpclient, httpContext);
		connectDialog.setLocationRelativeTo(frame);
		EventQueue.invokeLater(new Runnable() {

			@Override
			public void run() {
				loadBooks();
			}

		});
	}

	/**
	 * Выполняет загрузку...
	 */
	protected void doDownload() {
		if (books == null) {
			// Nothing to export
			JOptionPane.showMessageDialog(frame, "Нет книг к экспорту",
					"Экспорт книг", JOptionPane.ERROR_MESSAGE);
			return;
		}
		JFileChooser chooser = new JFileChooser();
		chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);
		chooser.setDialogTitle("Выберите место для сохранения");
		if (connectDialog.getSavePath() != null) {
			File saveTo = new File(connectDialog.getSavePath());
			if (saveTo.exists()) {
				chooser.setSelectedFile(saveTo);
			}
		}
		if (chooser.showOpenDialog(frame) == JFileChooser.APPROVE_OPTION) {
			final String saveTo = chooser.getSelectedFile().getAbsolutePath();
			// Сохраняем путь...
			connectDialog.setSavePath(saveTo);
			connectDialog.saveProperties();
			//
			downloadBtn.setEnabled(false);
			// Запускаем сохранение в отдельном потоке...
			new Thread(new Runnable() {

				@Override
				public void run() {
					try {
						SwingUtilities.invokeAndWait(new Runnable() {
							@Override
							public void run() {
								progressBar.setValue(0);
								progressBar.setMaximum(books.size());
							}
						});
					} catch (InterruptedException ignored) {
					} catch (InvocationTargetException ignored) {
					}
					for (final DownloaderBook book : books) {
						final StringBuffer pathToStore = new StringBuffer(
								saveTo
										+ File.separator
										+ Utils.cleanFileName(book
												.getAuthorsToString()));
						if (book.getSerieName() != null) {
							pathToStore.append(File.separator).append(
									Utils.cleanFileName(book.getSerieName()
											.trim()));
						}
						File outFile = new File(pathToStore.toString());
						if ((!outFile.exists()) && (!outFile.mkdirs())) {
							showError("Ошибка создания пути экспорта \""
									+ pathToStore.toString()
									+ "\"! Экспорт остановлен", null);
							return;
						}
						// Выгружаем книгу
						StringBuilder strUrl = new StringBuilder(connectDialog
								.getUrl()).append("?req=downloadbook&bookid=")
								.append(book.getBookId());
						HttpGet httpGet = new HttpGet(strUrl.toString());
						final HttpResponse response;
						try {
							response = httpclient.execute(httpGet, httpContext);
						} catch (final Exception e) {
							showError(
									"Ошибка выгрузки книги с идентификатором  "
											+ book.getBookId() + ". Ошибка - "
											+ e.getClass().getName() + " ("
											+ e.getMessage() + ")"
											+ "! Экспорт остановлен", httpGet);
							return;
						}
						if (response.getStatusLine().getStatusCode() == 200) {
							HttpEntity entity = response.getEntity();
							if (entity == null) {
								showError(
										"Ошибка выгрузки книги с идентификатором  "
												+ book.getBookId()
												+ ". Empty entity! Экспорт остановлен",
										httpGet);
								return;
							}
							//
							try {
								if (response
										.containsHeader("Content-disposition")) {
									Header header = response
											.getFirstHeader("Content-disposition");
									String fileName = header.getValue();
									fileName = URLDecoder.decode(
											fileName.substring(fileName
													.indexOf("\'\'") + 2),
											"UTF-8");
									fileName = pathToStore.toString()
											+ File.separator + fileName;
									File fileTo = new File(fileName);
									if (fileTo.exists()) {
										// Удаляем
										fileTo.delete();
									}
									try (InputStream input = response
											.getEntity().getContent()) {
										try (FileOutputStream output = new FileOutputStream(
												fileName)) {

										}
									}
									// Тут все наконец-то сохранилось...
									httpGet.abort();
								} else {
									showError(
											"Ошибка сохранения книги с идентификатором  "
													+ book.getBookId()
													+ ". Отсутствует \"Content-disposition\"! Экспорт остановлен",
											httpGet);
									return;
								}
							} catch (final Exception e) {
								showError(
										"Ошибка сохранения книги с идентификатором  "
												+ book.getBookId()
												+ ". Ошибка - "
												+ e.getClass().getName() + " ("
												+ e.getMessage() + ")"
												+ "! Экспорт остановлен",
										httpGet);
								return;
							}
						} else {
							showError(
									"Ошибка выгрузки книги с идентификатором  "
											+ book.getBookId()
											+ ". Status line - "
											+ response.getStatusLine()
											+ "! Экспорт остановлен", httpGet);
							return;
						}
						//
						SwingUtilities.invokeLater(new Runnable() {
							@Override
							public void run() {
								progressBar.setValue(progressBar.getValue() + 1);
							}
						});
					}
					try {
						SwingUtilities.invokeAndWait(new Runnable() {
							@Override
							public void run() {
								JOptionPane.showMessageDialog(frame,
										"Выгрузка завершена", "Экспорт книг",
										JOptionPane.INFORMATION_MESSAGE);
							}
						});
						return;
					} catch (InterruptedException ignored) {
					} catch (InvocationTargetException ignored) {
					}
					downloadBtn.setEnabled(true);
				}

				/**
				 * Выдает сообщение об ошибке
				 * 
				 * @param errorMessage
				 *            Сообщение
				 * @param httpGet
				 *            httpGet, которому будет сделан abort
				 */
				private void showError(final String errorMessage,
						HttpGet httpGet) {
					try {
						SwingUtilities.invokeAndWait(new Runnable() {
							@Override
							public void run() {
								JOptionPane.showMessageDialog(frame,
										errorMessage, "Экспорт книг",
										JOptionPane.ERROR_MESSAGE);
							}
						});
					} catch (InterruptedException ignored) {
					} catch (InvocationTargetException ignored) {
					}
					downloadBtn.setEnabled(true);
					if (httpGet != null) {
						httpGet.abort();
					}
				}

			}).start();
		}
	}

	/**
	 * 
	 */
	private void loadBooks() {
		books = null;
		connectDialog.setVisible(true);
		if (!connectDialog.isConnected()) {
			System.exit(0);
			return;
		}
		// Поехали грузить!
		// Формируем строку запроса - в дальнейшем мы ее будем дополнять
		StringBuilder str = new StringBuilder(connectDialog.getUrl())
				.append("?type=forReading&name=&req=books");
		HttpGet httpGet = new HttpGet(str.toString());
		HttpResponse response;
		try {
			response = httpclient.execute(httpGet, httpContext);
		} catch (Exception e) {
			JOptionPane.showMessageDialog(frame,
					"Ошибка загрузки списка книг к чтению - "
							+ e.getClass().getName() + ", \"" + e.getMessage()
							+ "\"", "Ошибка загрузки",
					JOptionPane.ERROR_MESSAGE);
			System.exit(0);
			return;
		}
		if (response.getStatusLine().getStatusCode() == 200) {
			HttpEntity entity = response.getEntity();
			if (entity == null) {
				JOptionPane.showMessageDialog(frame,
						"Ошибка загрузки списка книг к чтению - empty entity",
						"Ошибка загрузки", JOptionPane.ERROR_MESSAGE);
				System.exit(0);
				return;
			}
			GsonBuilder gsonBuilder = new GsonBuilder();
			gsonBuilder.setDateFormat("yyyy-MM-dd HH:mm:ss.SSS");
			Gson gson = gsonBuilder.create();
			ContentType contentType = ContentType.getOrDefault(entity);
			Charset charset = contentType.getCharset();
			Reader reader;
			try {
				reader = new InputStreamReader(entity.getContent(), charset);
			} catch (Exception e) {
				JOptionPane.showMessageDialog(
						frame,
						"Ошибка загрузки списка книг к чтению - "
								+ e.getClass().getName() + ", \""
								+ e.getMessage() + "\"", "Ошибка загрузки",
						JOptionPane.ERROR_MESSAGE);
				System.exit(0);
				return;
			}
			JsonParser parser = new JsonParser();
			JsonArray array = parser.parse(reader).getAsJsonArray();
			books = new ArrayList<>();
			for (int i = 0; i < array.size(); i++) {
				books.add(gson.fromJson(array.get(i), DownloaderBook.class));
			}
			DefaultMutableTreeNode root = new DefaultMutableTreeNode("root");
			if (books.size() > 0) {
				fillBookTree(root, books);
			} else {
				DefaultMutableTreeNode noExport = new DefaultMutableTreeNode(
						"Книги к выгрузке отсуствуют");
				root.add(noExport);
				downloadBtn.setEnabled(false);
			}
			((DefaultTreeModel) booksTree.getModel()).setRoot(root);
			((DefaultTreeModel) booksTree.getModel()).reload();
			booksTree.setSelectionPaths(null);
			for (int i = 0; i < booksTree.getRowCount(); i++) {
				booksTree.expandRow(i);
			}
		} else {
			JOptionPane.showMessageDialog(
					frame,
					"Ошибка загрузки списка книг к чтению - "
							+ response.getStatusLine(), "Ошибка загрузки",
					JOptionPane.ERROR_MESSAGE);
			System.exit(0);
		}
	}

	/**
	 * Заполняет список книг в дереве
	 * 
	 * @param root
	 *            Корень дерева
	 * @param books
	 *            Список книг
	 */
	private void fillBookTree(DefaultMutableTreeNode root,
			List<DownloaderBook> books) {
		// Сортируем - чтобы совсем не ломать hibernate mapping
		TreeSet<DownloaderBook> sortedBooks = new TreeSet<DownloaderBook>(
				new BookComparator());
		sortedBooks.addAll(books);
		DefaultMutableTreeNode serieNode = null;
		for (DownloaderBook book : sortedBooks) {
			if ((book.getSerieName() != null)
					&& (book.getSerieName().trim().length() > 0)) {
				// Есть серия!
				if ((serieNode == null)
						|| (!book.getSerieName().equals(
								serieNode.getUserObject()))) {
					serieNode = new DefaultMutableTreeNode(book.getSerieName());
					root.add(serieNode);
				}
			} else {
				// Серии нет - сбрасываем вершину
				serieNode = null;
			}
			DefaultMutableTreeNode bookNode = new DefaultMutableTreeNode(book);
			if (serieNode != null)
				serieNode.add(bookNode);
			else
				root.add(bookNode);
		}
	}

	/**
	 * Компаратор для сортировки книг
	 */
	private static class BookComparator implements Comparator<DownloaderBook> {
		@Override
		public int compare(DownloaderBook o1, DownloaderBook o2) {
			if ((o1.getSerieName() == null) && (o2.getSerieName() != null))
				// У первой нет серии, у второй - есть -> вторая должна быть
				// выше
				return 1;
			else if ((o2.getSerieName() == null) && (o1.getSerieName() != null))
				// У первой - есть серия, у второй - нет -> первая должна быть
				// выше
				return -1;
			else if ((o2.getSerieName() == null) && (o2.getSerieName() == null)) {
				// У обеих серий нет
				if ((o1.getTitle() != null))
					// Сраниваем по титлу первой
					if (o1.getTitle().equals(o2.getTitle())) {
						// Если заголовки совпадают - сравниваем по
						// идентификатору
						return (new Integer(o1.getId())).compareTo(new Integer(
								o2.getId()));
					} else
						return o1.getTitle().compareTo(o2.getTitle());
				else
					// У первой титлы нет - значит пусть она будет выше
					return -1;
			} else {
				// Тут у обеих есть серии
				if (o1.getSerieName().equals(o2.getSerieName())) {
					// Будем сравнивать по numInSerie
					if (o1.getNumInSerie() != null) {
						// У первой есть номер в серии - сравниваем с ним
						if (o2.getNumInSerie() != null)
							if (o1.getNumInSerie().equals(o2.getNumInSerie())) {
								return (new Integer(o1.getId()))
										.compareTo(new Integer(o2.getId()));
							} else
								return o1.getNumInSerie().compareTo(
										o2.getNumInSerie());
						else
							// У первой - есть номер серии, у второй - нету ->
							// первая будет ниже
							return 1;
					} else
						// У первой номера серии нету - значит пусть она будет
						// выше
						return -1;
				} else
					return o1.getSerieName().compareTo(o2.getSerieName());
			}
		}
	}

}
